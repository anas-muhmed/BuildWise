/**
 * ðŸŽ¯ Master's IaC Generator
 * Generate Terraform, K8s manifests, and CI/CD pipelines
 */

interface SnapshotNode {
  id: string;
  type: string;
  label: string;
  meta?: Record<string, unknown>;
}

interface IaCBundle {
  terraform: string;
  kubernetes?: string;
  githubActions: string;
  envTemplate: string;
  readme: string;
}

export function generateIaC(
  nodes: SnapshotNode[],
  projectName: string
): IaCBundle {
  const hasDB = nodes.some(n => n.type === 'database');
  const hasCache = nodes.some(n => n.type === 'cache');
  const hasStorage = nodes.some(n => n.type === 'blob_storage');

  // Terraform main.tf
  const terraform = `# Terraform configuration for ${projectName}
# Generated by BuildWise Architecture Builder

terraform {
  required_version = ">= 1.0"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region
}

# VPC and Networking
module "vpc" {
  source = "terraform-aws-modules/vpc/aws"
  
  name = "\${var.project_name}-vpc"
  cidr = "10.0.0.0/16"
  
  azs             = ["\${var.aws_region}a", "\${var.aws_region}b"]
  private_subnets = ["10.0.1.0/24", "10.0.2.0/24"]
  public_subnets  = ["10.0.101.0/24", "10.0.102.0/24"]
  
  enable_nat_gateway = true
  single_nat_gateway = var.environment == "dev"
}

${hasDB ? `
# RDS Database
resource "aws_db_instance" "main" {
  identifier           = "\${var.project_name}-db"
  engine               = "postgres"
  engine_version       = "15.3"
  instance_class       = var.db_instance_class
  allocated_storage    = 20
  storage_encrypted    = true
  
  db_name  = var.db_name
  username = var.db_username
  password = var.db_password # Use AWS Secrets Manager in production
  
  vpc_security_group_ids = [aws_security_group.db.id]
  db_subnet_group_name   = aws_db_subnet_group.main.name
  
  backup_retention_period = 7
  skip_final_snapshot     = var.environment == "dev"
}` : ''}

${hasCache ? `
# ElastiCache Redis
resource "aws_elasticache_cluster" "redis" {
  cluster_id           = "\${var.project_name}-redis"
  engine               = "redis"
  node_type            = "cache.t3.micro"
  num_cache_nodes      = 1
  parameter_group_name = "default.redis7"
  port                 = 6379
  
  subnet_group_name    = aws_elasticache_subnet_group.main.name
  security_group_ids   = [aws_security_group.redis.id]
}` : ''}

${hasStorage ? `
# S3 Bucket for storage
resource "aws_s3_bucket" "storage" {
  bucket = "\${var.project_name}-storage"
  
  tags = {
    Environment = var.environment
  }
}

resource "aws_s3_bucket_versioning" "storage" {
  bucket = aws_s3_bucket.storage.id
  
  versioning_configuration {
    status = "Enabled"
  }
}` : ''}

# ECS Cluster
resource "aws_ecs_cluster" "main" {
  name = "\${var.project_name}-cluster"
}

# Application Load Balancer
resource "aws_lb" "main" {
  name               = "\${var.project_name}-alb"
  internal           = false
  load_balancer_type = "application"
  security_groups    = [aws_security_group.alb.id]
  subnets            = module.vpc.public_subnets
}

# Variables
variable "project_name" {
  default = "${projectName}"
}

variable "environment" {
  default = "dev"
}

variable "aws_region" {
  default = "us-east-1"
}

${hasDB ? `variable "db_instance_class" {
  default = "db.t3.micro"
}

variable "db_name" {}
variable "db_username" {}
variable "db_password" {}` : ''}
`;

  // GitHub Actions CI/CD
  const githubActions = `name: Deploy ${projectName}

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: ${projectName}

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run linter
        run: npm run lint
      
      - name: Run tests
        run: npm test

  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: \${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: \${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: \${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
      
      - name: Build and push Docker image
        env:
          ECR_REGISTRY: \${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: \${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
      
      - name: Deploy to ECS
        run: |
          aws ecs update-service --cluster ${projectName}-cluster \\
            --service ${projectName}-service --force-new-deployment

  smoke-test:
    needs: build
    runs-on: ubuntu-latest
    
    steps:
      - name: Health check
        run: |
          curl -f https://${projectName}.example.com/health || exit 1
`;

  // Environment template
  const envTemplate = `# Environment Variables for ${projectName}
# Copy to .env.local and fill in values

# Database
${hasDB ? `DATABASE_URL=postgresql://user:password@localhost:5432/${projectName}
DB_HOST=localhost
DB_PORT=5432
DB_NAME=${projectName}
DB_USER=
DB_PASSWORD=` : '# No database configured'}

# Redis Cache
${hasCache ? `REDIS_URL=redis://localhost:6379
REDIS_HOST=localhost
REDIS_PORT=6379` : '# No cache configured'}

# AWS / Storage
${hasStorage ? `AWS_REGION=us-east-1
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
S3_BUCKET=${projectName}-storage` : '# No storage configured'}

# Application
NODE_ENV=development
PORT=3000
API_BASE_URL=http://localhost:3000

# JWT / Auth
JWT_SECRET=
SESSION_SECRET=

# Third-party APIs
${nodes.some(n => n.label.toLowerCase().includes('stripe')) ? `STRIPE_SECRET_KEY=
STRIPE_PUBLISHABLE_KEY=
STRIPE_WEBHOOK_SECRET=` : ''}

# Monitoring (optional)
${nodes.some(n => n.type === 'monitoring') ? `DATADOG_API_KEY=
SENTRY_DSN=` : ''}
`;

  // README
  const readme = `# ${projectName} - Deployment Guide

## Architecture Overview

This infrastructure was generated by BuildWise Architecture Builder.

**Components:**
${nodes.map(n => `- ${n.label} (${n.type})`).join('\n')}

## Prerequisites

- Terraform >= 1.0
- AWS CLI configured
- Docker
- Node.js 18+

## Quick Start

### 1. Configure Environment

\`\`\`bash
cp .env.example .env.local
# Edit .env.local with your values
\`\`\`

### 2. Deploy Infrastructure

\`\`\`bash
cd terraform
terraform init
terraform plan
terraform apply
\`\`\`

### 3. Deploy Application

\`\`\`bash
# Build Docker image
docker build -t ${projectName}:latest .

# Push to ECR (configure AWS credentials first)
aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin <account>.dkr.ecr.us-east-1.amazonaws.com
docker tag ${projectName}:latest <account>.dkr.ecr.us-east-1.amazonaws.com/${projectName}:latest
docker push <account>.dkr.ecr.us-east-1.amazonaws.com/${projectName}:latest
\`\`\`

### 4. Run Database Migrations

\`\`\`bash
npm run migrate
\`\`\`

## CI/CD

GitHub Actions pipeline is configured in \`.github/workflows/deploy.yml\`

**Required Secrets:**
- AWS_ACCESS_KEY_ID
- AWS_SECRET_ACCESS_KEY
${nodes.some(n => n.label.includes('Stripe')) ? '- STRIPE_SECRET_KEY' : ''}

## Monitoring

${nodes.some(n => n.type === 'monitoring') ? `Set up dashboards in Datadog/CloudWatch to monitor:
- Application latency (p95 < 500ms)
- Error rate (< 1%)
- Database connections
- Cache hit ratio` : 'No monitoring configured - consider adding Datadog or CloudWatch'}

## Rollback

\`\`\`bash
# Rollback to previous version
aws ecs update-service --cluster ${projectName}-cluster \\
  --service ${projectName}-service --task-definition <previous-task-def>
\`\`\`

## Cost Optimization

- Use t3.micro instances for dev/staging
- Enable S3 lifecycle policies
- Set up CloudWatch alarms for cost anomalies
- Review unused resources monthly

## Support

Generated on: ${new Date().toISOString()}
`;

  return {
    terraform,
    githubActions,
    envTemplate,
    readme
  };
}
